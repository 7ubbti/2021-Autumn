#                        ___<u>第二次考核任务</u>___

1.***自我介绍***

   - 性格
     - 有点网络依赖症，一跟真人说话就紧张，经常找不到话题尬聊（~~社交恐惧症~~），但是一旦玩熟了之后就很放得开了。
     - 性格还算比较乐观吧。
- 爱好
  - 吉他、听音乐
  - 打游戏
  - 看动漫
  - 收藏各种游戏、二次元周边和设定集
  - ~~传统手艺~~

---

---

2. ***最喜欢的游戏类型和一款游戏***

+ 最喜欢的游戏类型

  最喜欢的游戏类型是JRPG，因为这种游戏类型的代入感是任何游戏都无法比拟的，即使是老套到爆炸的“打败魔王拯救世界”这种剧情都能让我感动到流泪。这一喜好可以追溯到我的小学时代，那时候的游戏还是小霸王，对于我来说，父亲的触屏手机上的各种游戏是最吸引那个年纪的我的，可是那时的普通触屏手机性能还很烂，像“现代战争”、“狂野飙车”这些gameloft的“大作”是绝对带不动的，无奈之余我只能把眼光移向画质非常粗糙落后的“勇者斗恶龙”、“最终幻想”这些游戏（那时候SE已经做了Android移植版本了），但是我仍然一发不可收拾地沉浸进去了，并且这些老牌JRPG已经成为了我最宝贵的童年记忆（不知道还有没有人知道或者仍然记得[天幻网](www.ffsky.com)这个古董网站，那时候每次卡关的时候我会上去找一找攻略，那段时间真的很美好。可是网站创始人早已变成中年油腻大叔了，对游戏的一腔热血早已不复当年了，十四年之后，天幻网的时间永远停留在了2013年，成为那个时代最深刻的烙印，长大成人之后的我还会时不时上天幻网翻一翻攻略和几乎不再更新的论坛，回味那个令人怀念的、再也回不来的单纯的时代）。最大的遗憾还是最终幻想6吧，是我小学六年级的时候玩的，那时候我花了一个月的时间疯狂查攻略打到了世界的崩溃，已经推完了一大半的剧情了，结果手机却坏了，之后再也没有动力继续推完整篇游戏了。

---

+ 最喜欢的一款游戏

  最喜欢的一款游戏那必然是尼尔：机械纪元，我承认这是我这辈子玩过的最令我震撼的感动的游戏，横尾太郎的脑洞真的是突破天际，玩到E结局的时候，整个人都感动到发抖了，任何的言语都无法描述这个时候的感觉，除去这些方面，游戏的配乐可以说是顶级的了，真·买游戏送音乐，每首配乐都恰到好处，充分贴合游戏场景，很难想象白金工作室居然可以把司马SE给的那么一丁点经费发挥到这样的极限，即使是在满是空气墙的场景里面闲逛都是一种享受，另外游戏的游戏性也不算很弱，白金的外包保证了丰富的战斗系统和还算不错的打击感。游戏的支线也非常有深度，有的支线剧情甚至是超越了主线剧情的存在，不像法国某公司的游戏的支线，这里就不点名批评了。

  ***愿人类荣光永存！***

  

  

---

---

3. ***unity生命周期函数***

- Reset()函数

   Reset()函数是在用户在点击Inspector的Reset按钮时或着在首次挂载组件时被调用的一个函数，常用于给组件设置为给定默认值 



- Awake()函数

   Awake()函数在脚本实例被载入时就被调用，不管游戏对象是否被激活都会被调用，在整个游戏当中只会被调用一次和构造函数差不多，运行于Start()函数之前，Awake()主要被用于初始化游戏状态或变量 

  

- Start()函数

  在第一次调用Update方法之前时，在这一帧之前调用Start()。
  与Awake函数一样，Start在脚本的生命周期中只调用一次。但是，无论脚本是否已启用，都会在初始化脚本对象时调用Awake。如果在初始化时未启用脚本，则可能无法调用Start()函数 。
  在调用任何对象的Start函数之前，将在场景中的所有对象上调用Awake函数

  

- Update()函数

  如果启用了MonoBehaviour，则每一帧被调用。
  
  Update是实现任何类型的游戏脚本最常用的功能。不是每个MonoBehaviour脚本都需要Update。
  
  

- LateUpdate()函数

  如果启用了MonoBehaviour，则每帧都会调用LateUpdate 。

  在调用所有Update函数后调用LateUpdate。这对于顺序脚本执行很有用。例如，跟随摄像机应始终在LateUpdate中实现，因为它跟踪可能已在Update内移动的对象。

  

- FixedUpdate()函数

   如果启用了MonoBehaviour，则每个固定帧率帧都会调用此函数（可设置帧率步长）。
  在处理Rigidbody时，应该使用FixedUpdate而不是Update 。例如，当向刚体添加力时，必须在FixedUpdate内的每个固定帧上应用力，而不是在Update中的每个帧。 

  

- OnEnable()函数

   当对象变为启用和激活时，将调用此函数。
  OnEnable不能用于协同程序。 

  

- OnTriggerXXX(Collider other)函数

  进入触发器void OnTriggerEnter (Collider other) 当Collider(碰撞体)进入trigger(触发器)时调用OnTriggerEnter。

  逗留触发器void OnTriggerStay (Collider other) 当碰撞体接触触发器时，OnTriggerStay将在每一帧被调用。

  退出触发器void OnTriggerExit (Collider other)当Collider(碰撞体)停止触发trigger(触发器)时调用OnTriggerExit。

  

- OnCollider(Collision CollisionInfo)函数

  Collider.OnCollisionEnter
  当此对撞机/刚体开始接触另一个刚体/对撞机时，将调用OnCollisionEnter。

  Collider.OnCollisionExit
  当此对撞机/刚体停止接触另一个刚体/对撞机时，将调用OnCollisionExit。

  Collider.OnCollisionStay
  对于每个碰撞刚体/对撞机逗留与另一个碰撞器/刚体时，OnCollisionStay每帧调用一次。


- OnMouseXXX()函数

  MonoBehaviour.OnMouseDown
  当用户在GUIElement或Collider上按下鼠标按钮时，将调用OnMouseDown。

  MonoBehaviour.OnMouseDrag
  当用户单击GUIElement或Collider并且仍然按住鼠标时，将调用OnMouseDrag。

  MonoBehaviour.OnMouseEnter
  当鼠标进入GUIElement或Collider时调用。

  MonoBehaviour.OnMouseExit
  当鼠标不再位于GUIElement或Collider上时调用。

  MonoBehaviour.OnMouseOver
  鼠标悬停在GUIElement或Collider上时调用每一帧。

  MonoBehaviour.OnMouseUp
  用户释放鼠标按钮时调用OnMouseUp。

  

- OnGUI()函数

   OnGUI调用用于呈现和处理GUI事件。
  这意味着您的OnGUI实现可能会在每个帧中被调用多次(每个事件一次调用)。 

  

- OnDisable()函数

  当行为被禁用时，将调用此函数。

  当对象被销毁时也可以调用它，并且可以用于任何清理代码。编译完成后重新加载脚本时，将调用OnDisable，然后在加载脚本后调用OnEnable。

  

- OnDestroy()函数

  销毁附加的行为将导致游戏或场景启动OnDestroy。

  场景或游戏结束时调用OnDestroy。任何方法都会导致调用OnDestroy。从编辑器内部运行时，停止播放模式将结束应用程序。当这一结束时，将执行OnDestroy。此外，如果关闭场景并加载新场景，则将进行OnDestroy调用。
  当作为独立应用程序构建时，OnDestroy会在场景结束时进行调用。场景结束通常意味着加载了新场景。
  OnDestroy仅在以前处于活动状态的游戏对象上调用。

---

---

4. ***本周基础知识学习笔记***

   

| Markdown       | 具体操作                                                     |
| :------------- | ------------------------------------------------------------ |
| Markdown 标题  | 使用 **#** 号可表示 1-6 级标题，一级标题对应一个 **#** 号，二级标题对应两个 **#** 号，以此类推 |
| Markdown字体   | 字体左右各加一个星号（*）或下划线（_）来实现斜体文本，字体左右各加两个星号或下划线来实现粗体文本，字体左右各加三个星号或下划线来同时实现斜体文本和粗体文本 |
| Markdown分割线 | 在一行中用三个以上的星号*、减号-、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格 |
| Markdown删除线 | 如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 **~~** 即可 |
| Markdown下划线 | 下划线可以通过 HTML 的<u>标签来实现                          |
| Markdown列表   | 无序列表使用星号(*****)、加号(**+**)或是减号(**-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容，有序列表使用数字并加上 **.** 号来表示，列表嵌套只需在子列表中的选项前面添加四个空格 |
| Markdown区块   | Markdown 区块引用是在段落开头使用 **>** 符号 ，然后后面紧跟一个**空格**符号，区块是可以嵌套的，一个 **>** 符号是最外层，两个 **>** 符号是第一层嵌套，以此类推，如果要在列表项目内放进区块，那么就需要在 **>** 前添加四个空格的缩进 |
| Markdown链接   | [链接名称](链接地址)或者直接<链接地址>                       |
| Markdown表格   | Markdown 制作表格使用\|来分隔不同的单元格，使用 **-** 来分隔表头和其他行。**-:** 设置内容和标题栏居右对齐，**:-** 设置内容和标题栏居左对齐，**:-:** 设置内容和标题栏居中对齐 |

