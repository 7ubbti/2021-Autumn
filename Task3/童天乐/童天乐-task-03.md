# 基础知识考察   
## vector与数组有哪些区别？  	
1. 内存中的位置中  
* 数组为内置的数据类型，存放在栈中，其内存的分配和释放完全由系统自动完成.  
* vector，存放在堆中，由STL库中程序负责内存的分配和释放，使用方便.  
2. 大小能否变化  
* 数组的大小在初始化后就固定不变.  
* vector可以通过push_back或pop等操作进行变化.  
3. 初始化  
* 数组不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值.  
* 而向量可以.  
4. 执行效率  
* 数组>vector向量。主要原因是vector的扩容过程要消耗大量的时间。  
## 编程：利用两个队列来实现一个栈    
* 见附件 Queue to Stack.cpp

# 坦克大战更新思路
1. 首先这是坦克，撞到墙竟然不会扣血，这显然是不合理的，为了坚持科学的准则，加入了与墙体等场景物体碰撞时也会产生被攻击时的效果，当然也少不了坦克撞坦克XD.以下是代码。  
'''c#
private void OnCollisionEnter( Collision col ){
	if (col.gameObject.tag == "Walls" || col.gameObject.tag == "Tank" ) { //为除了地面之外的其他场景物体定为标签Walls.
	RushDamage(); // hp -= Random.Range(2,5);
	}
}
'''  
2. 其次考虑到炮弹过于单一，于是Copy改色了一个红色炮弹的预制件，整体代码同普通炮弹，但调用的函数为TakeRedDamage() //hp -= Random.Range(30,40); 随机伤害更高，同时使其具有AOE范围伤害的能力，坦克预制件底部设置了一个Mesh 碰撞检测，标签AOE plane，触碰时调用 TakeAoeDamage() // hp -= Random.Range(5, 10);  
3. 由于上帝视角玩家（舍友）体验较差，于是改为分屏第一人称视角。操作不难。
4. 望着硕大的场景，却只有空荡荡的，内心多少有点失落。于是添加了一些随机生成位置//Random.Range() 的可拾取道具，同RollABall。分别是提速，回血，炮弹X2；
5. 自定义方面，因为玩家（舍友）提出要自定义坦克颜色，于是便加入了选色 并且使用 // PlayerPrefs.SetInt()，进行场景传递。
6. 添加主界面和ESC暂停菜单。
7. 添加积分系统，判断胜负并高光特写镜头。

